var N=null,E="",T="t",U="u",searchIndex={};
var R=["result","string","huffman","huffman::huffman_tree","weight","encode_to","usize","hashmap","decode_to","huffman::bits","try_from","try_into","borrow_mut","type_id","huffmantree","ordering","BitWriter","Biterator","HuffmanTree"];
searchIndex["huffman"]={"doc":E,"i":[[5,"encode",R[2],"A wrapper function that encodes a string and returns a…",N,[[["str"]],[[R[0],["vec"]],["vec",["u8"]]]]],[5,R[5],E,"A memory efficient function for encoding.",N,[[["a"],["b"]],[R[0]]]],[5,R[8],E,"A memory efficient function for decoding.",N,[[["a"],["b"]],[R[0]]]],[5,"decode",E,"A wrapper function for decoding.",N,[[],[[R[1]],[R[0],[R[1]]]]]],[0,"bits",E,"A module containing structs and functions that help the…",N,N],[3,R[16],R[9],"A struct for writing bits to a `Write`.",N,N],[3,R[17],E,"A struct for reading bits from a `Read`.",N,N],[5,"get_bit",E,"Read the bit at `idx`.",N,[[[R[6]]],["bool"]]],[5,"set_bit",E,"Set the bit at `idx` to the given value.",N,[[["bool"],[R[6]]]]],[11,"new",E,"Construct a new `BitWriter` which will read from the…",0,[[["write"]],["bitwriter"]]],[11,"push",E,"Push a new value into the buffer.",0,[[["self"],["bool"]],[R[0]]]],[11,"flush",E,E,0,[[["self"]],[R[0]]]],[11,"new",E,"Construct a new `Biterator` which will read from the…",1,[[["read"]],["biterator"]]],[0,"huffman_tree",R[2],"A module that defining a `HuffmanTree`.",N,N],[4,R[18],R[3],"The struct representing the Huffman tree.",N,N],[13,"Node",E,E,2,N],[12,R[4],"huffman::huffman_tree::HuffmanTree",E,2,N],[12,"zero",E,E,2,N],[12,"one",E,E,2,N],[13,"Leaf",R[3],E,2,N],[11,R[4],E,"Get the weight of the tree.",2,[[["self"]],[R[6]]]],[11,"from",E,"Construct a `HuffmanTree` from character frequencies.",2,[[[R[7]]],[R[14]]]],[11,R[5],E,"Encode data from `input` and write it to `output`.",2,[[["self"],["a"],["b"]],[[R[6]],[R[0],[R[6]]]]]],[11,"codes",E,"Return a map of the generated encodings",2,[[["self"]],[[R[7],["char","vec"]],["char"],["vec",["bool"]]]]],[11,R[8],E,"Decode data from `input` and write it to `output`.",2,[[["self"],[R[6]],["b"],["a"]],[R[0]]]],[11,"from",R[9],E,0,[[[T]],[T]]],[11,"into",E,E,0,[[],[U]]],[11,R[10],E,E,0,[[[U]],[R[0]]]],[11,R[11],E,E,0,[[],[R[0]]]],[11,"borrow",E,E,0,[[["self"]],[T]]],[11,R[12],E,E,0,[[["self"]],[T]]],[11,R[13],E,E,0,[[["self"]],["typeid"]]],[11,"into_iter",E,E,1,[[],["i"]]],[11,"from",E,E,1,[[[T]],[T]]],[11,"into",E,E,1,[[],[U]]],[11,R[10],E,E,1,[[[U]],[R[0]]]],[11,R[11],E,E,1,[[],[R[0]]]],[11,"borrow",E,E,1,[[["self"]],[T]]],[11,R[12],E,E,1,[[["self"]],[T]]],[11,R[13],E,E,1,[[["self"]],["typeid"]]],[11,"to_owned",R[3],E,2,[[["self"]],[T]]],[11,"clone_into",E,E,2,[[["self"],[T]]]],[11,"from",E,E,2,[[[T]],[T]]],[11,"into",E,E,2,[[],[U]]],[11,R[10],E,E,2,[[[U]],[R[0]]]],[11,R[11],E,E,2,[[],[R[0]]]],[11,"borrow",E,E,2,[[["self"]],[T]]],[11,R[12],E,E,2,[[["self"]],[T]]],[11,R[13],E,E,2,[[["self"]],["typeid"]]],[11,"clone",E,E,2,[[["self"]],[R[14]]]],[11,"partial_cmp",E,E,2,[[["self"],[R[14]]],[[R[15]],["option",[R[15]]]]]],[11,"eq",E,E,2,[[["self"],[R[14]]],["bool"]]],[11,"ne",E,E,2,[[["self"],[R[14]]],["bool"]]],[11,"next",R[9],E,1,[[["self"]],["option"]]],[11,"cmp",R[3],E,2,[[["self"],[R[14]]],[R[15]]]],[11,"fmt",E,E,2,[[["self"],["formatter"]],[R[0]]]],[11,"serialize",E,E,2,[[["self"],["__s"]],[R[0]]]],[11,"deserialize",E,E,2,[[["__d"]],[R[0]]]]],"p":[[3,R[16]],[3,R[17]],[4,R[18]]]};
initSearch(searchIndex);addSearchOptions(searchIndex);